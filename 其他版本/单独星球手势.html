<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²’å­æ˜Ÿçƒ - æ‰‹åŠ¿æ§åˆ¶</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* æ‘„åƒå¤´é¢„è§ˆå’ŒUIè¦†ç›–å±‚ */
        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 10;
            pointer-events: none; /* è®©é¼ æ ‡ç©¿é€åˆ°ThreeJS */
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .input_video {
            width: 160px;
            height: 120px;
            border-radius: 10px;
            border: 2px solid rgba(255, 140, 0, 0.5);
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            background: #111;
            opacity: 0.8;
        }

        .status-panel {
            color: rgba(255, 255, 255, 0.9);
            background: rgba(0, 0, 0, 0.6);
            padding: 15px;
            border-radius: 10px;
            border-left: 4px solid #ff8c00;
            max-width: 300px;
        }

        h1 {
            margin: 0 0 5px 0;
            font-size: 1.2rem;
            color: #ff8c00;
            text-shadow: 0 0 10px rgba(255, 140, 0, 0.5);
        }

        p {
            margin: 5px 0;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .highlight {
            color: #fff;
            font-weight: bold;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff8c00;
            font-size: 24px;
            z-index: 20;
            text-shadow: 0 0 20px orange;
        }
    </style>

    <!-- 1. å¼•å…¥ MediaPipe (å¸¸è§„ Script æ–¹å¼) -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- 2. å¼•å…¥ Three.js (ES Module æ–¹å¼) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">æ­£åœ¨å¯åŠ¨æ˜Ÿé™…å¼•æ“ (åŠ è½½æ¨¡å‹ä¸­)...</div>

    <div id="ui-layer">
        <video class="input_video" playsinline></video>
        <div class="status-panel">
            <h1>ç²’å­æ˜Ÿçƒæ§åˆ¶å™¨</h1>
            <p>ğŸ‘‹ <b>æ—‹è½¬æ‰‹æŒ:</b> æ—‹è½¬è§†è§’ (åƒæ‹¨åŠ¨æ˜Ÿçƒ)</p>
            <p>âœŠ <b>æ¡æ‹³ + è¿œç¦»:</b> é•œå¤´æ‹‰è¿œ (åŠ é€Ÿ)</p>
            <p>ğŸ– <b>å¼ å¼€ + é è¿‘:</b> é•œå¤´æ‹‰è¿‘ (å‡é€Ÿ)</p>
            <p>çŠ¶æ€: <span id="gesture-status" class="highlight">ç­‰å¾…æ‰‹åŠ¿...</span></p>
        </div>
    </div>

    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';

        // ==========================================
        // 1. å…¨å±€é…ç½® & çŠ¶æ€ç®¡ç†
        // ==========================================
        const CONFIG = {
            planetRadius: 25,
            planetColor: 0xff6600, // æ·±æ©™è‰²
            ringColor: 0xffffff,
            particleSize: 1.2,
            minDist: 40,   // æ‘„åƒæœºæœ€è¿‘è·ç¦»
            maxDist: 200,  // æ‘„åƒæœºæœ€è¿œè·ç¦»
            defaultDist: 100
        };

        const STATE = {
            targetCameraRadius: CONFIG.defaultDist,
            currentCameraRadius: CONFIG.defaultDist,
            targetCameraAngle: 0,
            currentCameraAngle: 0,
            handRotationOffset: 0,
            isHandDetected: false,
            gesture: 'NONE', // 'FIST', 'OPEN', 'NONE'
            lastHandSize: 0
        };

        const statusEl = document.getElementById('gesture-status');
        const loadingEl = document.getElementById('loading');

        // ==========================================
        // 2. Three.js åœºæ™¯æ„å»º
        // ==========================================
        const scene = new THREE.Scene();
        // æ·»åŠ ä¸€ç‚¹èƒŒæ™¯é›¾ï¼Œå¢åŠ æ·±é‚ƒæ„Ÿ
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = CONFIG.defaultDist;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // æ€§èƒ½ä¼˜åŒ–
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- ç”Ÿæˆå‘å…‰ç²’å­çº¹ç† ---
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // å¾„å‘æ¸å˜ï¼šä¸­å¿ƒç™½ -> ä¸­é—´åŸè‰² -> è¾¹ç¼˜é€æ˜
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.4, 'rgba(255, 255, 255, 0.8)');
            gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        const particleTexture = createGlowTexture();

        // --- æ„å»ºæ˜Ÿçƒ (æ©™è‰²) ---
        const planetGeometry = new THREE.BufferGeometry();
        const planetCount = 4000;
        const planetPositions = new Float32Array(planetCount * 3);
        const planetSizes = new Float32Array(planetCount);

        for (let i = 0; i < planetCount; i++) {
            // çƒé¢åˆ†å¸ƒç®—æ³•
            const phi = Math.acos(-1 + (2 * i) / planetCount);
            const theta = Math.sqrt(planetCount * Math.PI) * phi;
            
            // åŸºç¡€åŠå¾„ + å°‘é‡éšæœºåç§» (è®©å®ƒçœ‹èµ·æ¥è“¬æ¾) + è¡¨é¢èšé›†
            // å¤§éƒ¨åˆ†ç²’å­åœ¨è¡¨é¢ï¼Œå°‘éƒ¨åˆ†åœ¨å†…éƒ¨
            let r = CONFIG.planetRadius;
            const random = Math.random();
            if (random > 0.8) {
                // 20% çš„ç²’å­åœ¨å†…éƒ¨æˆ–ç¨å¤–éƒ¨ï¼Œåˆ¶é€ ä½“ç§¯æ„Ÿ
                r += (Math.random() - 0.5) * 5; 
            } else {
                // 80% ç´§è´´è¡¨é¢
                r += (Math.random() - 0.5) * 1; 
            }

            const x = r * Math.cos(theta) * Math.sin(phi);
            const y = r * Math.sin(theta) * Math.sin(phi);
            const z = r * Math.cos(phi);

            planetPositions[i * 3] = x;
            planetPositions[i * 3 + 1] = y;
            planetPositions[i * 3 + 2] = z;

            // éšæœºå¤§å°
            planetSizes[i] = Math.random() * 2 + 0.5;
        }

        planetGeometry.setAttribute('position', new THREE.BufferAttribute(planetPositions, 3));
        planetGeometry.setAttribute('size', new THREE.BufferAttribute(planetSizes, 1));

        // è‡ªå®šä¹‰ Shader Material æˆ–è€…ä½¿ç”¨ PointsMaterial 
        // ä¸ºäº†ç®€å•ä¸”æ•ˆæœå¥½ï¼Œæˆ‘ä»¬ä½¿ç”¨ PointsMaterial é…åˆ map
        const planetMaterial = new THREE.PointsMaterial({
            color: CONFIG.planetColor,
            size: CONFIG.particleSize,
            map: particleTexture,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending, // å…³é”®ï¼šå åŠ å˜äº®
            depthWrite: false,
            sizeAttenuation: true
        });

        const planet = new THREE.Points(planetGeometry, planetMaterial);
        scene.add(planet);

        // --- æ„å»ºæ˜Ÿç¯ (ç™½è‰²) ---
        const ringGeometry = new THREE.BufferGeometry();
        const ringCount = 2000;
        const ringPositions = new Float32Array(ringCount * 3);

        for (let i = 0; i < ringCount; i++) {
            // ä¸¤ä¸ªç¯å¸¦
            const band = Math.random() > 0.5 ? 1 : 2;
            let r;
            if (band === 1) r = 35 + Math.random() * 10; // å†…ç¯
            else r = 55 + Math.random() * 15;            // å¤–ç¯

            const angle = Math.random() * Math.PI * 2;
            
            // ç¯ä¸»è¦åœ¨ XZ å¹³é¢ï¼ŒY è½´ç»™å¾ˆå°‘çš„æŠ–åŠ¨
            const x = r * Math.cos(angle);
            const y = (Math.random() - 0.5) * 2; 
            const z = r * Math.sin(angle);

            ringPositions[i * 3] = x;
            ringPositions[i * 3 + 1] = y;
            ringPositions[i * 3 + 2] = z;
        }
        
        ringGeometry.setAttribute('position', new THREE.BufferAttribute(ringPositions, 3));

        const ringMaterial = new THREE.PointsMaterial({
            color: CONFIG.ringColor,
            size: CONFIG.particleSize * 0.8,
            map: particleTexture,
            transparent: true,
            opacity: 0.6,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const rings = new THREE.Points(ringGeometry, ringMaterial);
        //ç¨å¾®å€¾æ–œä¸€ç‚¹æ˜Ÿç¯ï¼Œè®©è§†è§‰æ›´å¥½çœ‹
        rings.rotation.x = Math.PI / 8; 
        rings.rotation.z = Math.PI / 12;
        scene.add(rings);


        // ==========================================
        // 3. åŠ¨ç”»ä¸ç‰©ç†é€»è¾‘
        // ==========================================
        
        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ‰‹æŒæ—‹è½¬è§’åº¦ (Roll)
        function getHandRotation(landmarks) {
            // ä½¿ç”¨æ‰‹è…•(0)å’Œä¸­æŒ‡æŒ‡æ ¹(9)æ¥è®¡ç®—è§’åº¦
            const wrist = landmarks[0];
            const middleBase = landmarks[9];
            // è®¡ç®—å‘é‡è§’åº¦
            const dx = middleBase.x - wrist.x;
            const dy = middleBase.y - wrist.y;
            // å› ä¸ºå±å¹•åæ ‡ç³» Y æ˜¯å‘ä¸‹çš„ï¼Œä¸”æˆ‘ä»¬å¸Œæœ›é¡ºæ—¶é’ˆæ—‹è½¬å¯¹åº”é¡ºæ—¶é’ˆ
            return Math.atan2(dy, dx); 
        }

        // è¾…åŠ©å‡½æ•°ï¼šè®¡ç®—æ‰‹æŒâ€œå¤§å°â€ï¼ˆä½œä¸ºè·ç¦»çš„ä»£ç†ï¼‰
        function getHandSize(landmarks) {
            const wrist = landmarks[0];
            const middleTip = landmarks[12];
            // è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦»
            return Math.sqrt(Math.pow(wrist.x - middleTip.x, 2) + Math.pow(wrist.y - middleTip.y, 2));
        }

        // è¾…åŠ©å‡½æ•°ï¼šåˆ¤æ–­æ¡æ‹³
        function isFist(landmarks) {
            // ç®€å•é€»è¾‘ï¼šæŒ‡å°–(Tip) åˆ° æ‰‹è…•(0) çš„è·ç¦» < æŒ‡å…³èŠ‚(PIP) åˆ° æ‰‹è…•çš„è·ç¦»
            // æ£€æŸ¥ é£ŸæŒ‡(8 vs 6), ä¸­æŒ‡(12 vs 10), æ— åæŒ‡(16 vs 14), å°æŒ‡(20 vs 18)
            const wrist = landmarks[0];
            function dist(idx) {
                return Math.sqrt(Math.pow(landmarks[idx].x - wrist.x, 2) + Math.pow(landmarks[idx].y - wrist.y, 2));
            }
            // å¦‚æœ 3 ä¸ªä»¥ä¸Šæ‰‹æŒ‡æ˜¯å·æ›²çš„ï¼Œè®¤ä¸ºæ˜¯æ¡æ‹³
            let foldedFingers = 0;
            if (dist(8) < dist(6)) foldedFingers++;
            if (dist(12) < dist(10)) foldedFingers++;
            if (dist(16) < dist(14)) foldedFingers++;
            if (dist(20) < dist(18)) foldedFingers++;

            return foldedFingers >= 3;
        }

        function isPalmOpen(landmarks) {
             const wrist = landmarks[0];
            function dist(idx) {
                return Math.sqrt(Math.pow(landmarks[idx].x - wrist.x, 2) + Math.pow(landmarks[idx].y - wrist.y, 2));
            }
            // 4ä¸ªæ‰‹æŒ‡éƒ½ä¼¸ç›´
            let openFingers = 0;
            if (dist(8) > dist(6)) openFingers++;
            if (dist(12) > dist(10)) openFingers++;
            if (dist(16) > dist(14)) openFingers++;
            if (dist(20) > dist(18)) openFingers++;
            
            return openFingers === 4;
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. æ˜Ÿçƒè‡ªè½¬ (æ— æ“ä½œæ—¶ä¹Ÿæœ‰è½»å¾®è½¬åŠ¨)
            planet.rotation.y += 0.001;
            rings.rotation.y -= 0.0005; // é€†å‘æ—‹è½¬å¢åŠ å±‚æ¬¡æ„Ÿ

            // 2. æ‘„åƒæœºé€»è¾‘
            if (STATE.isHandDetected) {
                // --- æ—‹è½¬æ§åˆ¶ ---
                // ä½¿ç”¨ Lerp å¹³æ»‘è¿‡æ¸¡è§’åº¦
                // è§’åº¦å¢é‡å¾ˆå°ï¼Œç´¯åŠ åˆ° currentCameraAngle
                // è¿™é‡Œæˆ‘ä»¬ç›´æ¥æŠŠæ‰‹æŒçš„ç»å¯¹è§’åº¦æ˜ å°„ä¸ºæ‘„åƒæœºçš„åç§»
                // ä¸ºäº†é¿å…è·³å˜ï¼Œæˆ‘ä»¬ä½¿ç”¨å·®å€¼æˆ–è€…ç›¸å¯¹å€¼ä¼šæ›´å¥½ã€‚
                // ç®€åŒ–æ–¹æ¡ˆï¼šæ¯ä¸€å¸§å¦‚æœæ‰‹åœ¨è½¬ï¼Œæ‘„åƒæœºå°±è·Ÿç€è½¬
                
                // å°†æ‰‹åŠ¿è§’åº¦ç›´æ¥æ˜ å°„ä¸ºæ‘„åƒæœºçš„æ°´å¹³è½¨é“è§’
                // åŠ ä¸Šä¸€ä¸ªåŸºç¡€æ—‹è½¬è®©å®ƒåŠ¨èµ·æ¥
                const targetAngle = -STATE.handRotationOffset * 2.5; // ç³»æ•°è°ƒæ•´çµæ•åº¦
                STATE.currentCameraAngle += (targetAngle - STATE.currentCameraAngle) * 0.1;
            } else {
                // å¦‚æœæ²¡æœ‰æ‰‹ï¼Œè‡ªåŠ¨ç¼“æ…¢æ—‹è½¬
                STATE.currentCameraAngle += 0.002;
            }

            // --- ç¼©æ”¾/è·ç¦»æ§åˆ¶ ---
            // ç‰©ç†å…¬å¼æ¨¡æ‹Ÿï¼šå…ˆå¿«åæ…¢ æˆ– å…ˆæ…¢åå¿«
            // æˆ‘ä»¬é€šè¿‡åŠ¨æ€æ”¹å˜ Lerp çš„ alpha å€¼æˆ–è€…å¢åŠ éçº¿æ€§æ˜ å°„æ¥å®ç°
            
            // è®¡ç®—è·ç¦»è¯¯å·®
            const distDiff = STATE.targetCameraRadius - STATE.currentCameraRadius;
            
            let lerpFactor = 0.05; // é»˜è®¤å¹³æ»‘åº¦

            if (STATE.gesture === 'FIST') {
                // æ¡æ‹³æ‹‰è¿œï¼šé€Ÿåº¦å…ˆæ…¢åå¿«
                // è·ç¦»ç›®æ ‡è¶Šè¿œï¼Œç§»åŠ¨è¶Šæ…¢ï¼Ÿä¸å¯¹ï¼Œå…ˆæ…¢åå¿«æ„å‘³ç€åŠ é€Ÿåº¦ã€‚
                // æˆ‘ä»¬ä½¿ç”¨æŒ‡æ•°é€¼è¿‘
                // æˆ–è€…ç®€å•ç‚¹ï¼šæ ¹æ®è·ç¦»å·®åŠ¨æ€è°ƒæ•´ lerpFactor
                // å½“åˆšå¼€å§‹ç§»åŠ¨(è·ç¦»å·®å¤§)æ—¶æ…¢ -> factor å°
                // å½“ç§»åŠ¨äº†ä¸€æ®µåå¿« -> factor å¤§
                // ä½†æ ‡å‡†çš„ Lerp æ˜¯è·ç¦»å·®å¤§é€Ÿåº¦å¿«ã€‚
                // åå‘ Lerp: speed = base + (1 - normalized_dist)
                
                // ä¸ºäº†å®ç°â€œå…ˆæ…¢åå¿«è¿œç¦»â€ï¼Œæˆ‘ä»¬è®© Target ç¬é—´å˜è¿œï¼Œä½† Current çš„è¿½è¸ªé€Ÿåº¦éšæ—¶é—´å¢åŠ 
                // è¿™é‡Œç®€åŒ–æ¨¡æ‹Ÿï¼š
                // å¦‚æœæ˜¯è¿œç¦»æ“ä½œï¼Œæˆ‘ä»¬ç»™ä¸€ä¸ªè¾ƒå°çš„ lerpï¼Œæ¨¡æ‹Ÿæ²‰é‡æ„Ÿï¼ˆæ…¢ï¼‰ï¼Œç„¶åå› ä¸ºè·ç¦»å·®å˜å¤§ï¼Œç‰©ç†é€Ÿåº¦è‡ªç„¶ä¼šå˜å¿«(å¦‚æœç”¨é€Ÿåº¦ç´¯åŠ )
                // è®©æˆ‘ä»¬ç”¨ç®€å•çš„éçº¿æ€§æ’å€¼ï¼š
                lerpFactor = 0.02; // æ…¢å¯åŠ¨
                // æ‰‹åŠ¨åŠ é€Ÿé€»è¾‘
                if (Math.abs(distDiff) > 10) {
                    lerpFactor = 0.08; // åªè¦åŠ¨èµ·æ¥äº†å°±å˜å¿«
                }
            } else if (STATE.gesture === 'OPEN') {
                // 5æŒ‡å¼ å¼€é è¿‘ï¼šé€Ÿåº¦å…ˆå¿«åæ…¢
                // è¿™æ­£æ˜¯æ ‡å‡† Lerp çš„ç‰¹æ€§ï¼šè·ç¦»è¿œæ—¶è·¨åº¦å¤§(å¿«)ï¼Œæ¥è¿‘ç›®æ ‡æ—¶è·¨åº¦å°(æ…¢)
                lerpFactor = 0.15; // åˆå§‹è¿™å°±å¾ˆå¿«
            }

            STATE.currentCameraRadius += (STATE.targetCameraRadius - STATE.currentCameraRadius) * lerpFactor;

            // é™åˆ¶èŒƒå›´
            if (STATE.currentCameraRadius < CONFIG.minDist) STATE.currentCameraRadius = CONFIG.minDist;
            if (STATE.currentCameraRadius > CONFIG.maxDist) STATE.currentCameraRadius = CONFIG.maxDist;

            // 3. æ›´æ–°æ‘„åƒæœºä½ç½® (çƒåæ ‡è½¬ç¬›å¡å°”åæ ‡)
            // y è½´ç¨å¾®æŠ¬é«˜ä¸€ç‚¹ï¼Œä¿¯è§†
            const camX = Math.sin(STATE.currentCameraAngle) * STATE.currentCameraRadius;
            const camZ = Math.cos(STATE.currentCameraAngle) * STATE.currentCameraRadius;
            const camY = STATE.currentCameraRadius * 0.3; 

            camera.position.set(camX, camY, camZ);
            camera.lookAt(0, 0, 0);

            // æ¸²æŸ“
            renderer.render(scene, camera);
        }

        animate();

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });


        // ==========================================
        // 4. MediaPipe é›†æˆ
        // ==========================================
        
        function onResults(results) {
            loadingEl.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                STATE.isHandDetected = true;

                // 1. æ—‹è½¬è®¡ç®—
                const rotation = getHandRotation(landmarks);
                // å¹³æ»‘å¤„ç†è§’åº¦ï¼Œé˜²æ­¢æŠ–åŠ¨ (Low pass filter)
                STATE.handRotationOffset = rotation - Math.PI / 2; // ä¿®æ­£åŸºå‡†ï¼Œè®©å‚ç›´æ‰‹æŒä¸º0åº¦

                // 2. çŠ¶æ€ & è·ç¦»è®¡ç®—
                const handSize = getHandSize(landmarks); // èŒƒå›´é€šå¸¸åœ¨ 0.1 åˆ° 0.4 ä¹‹é—´ (å–å†³äºæ‘„åƒå¤´è·ç¦»)
                
                // åˆ¤æ–­æ‰‹åŠ¿
                if (isFist(landmarks)) {
                    STATE.gesture = 'FIST';
                    statusEl.innerText = "âœŠ æ¡æ‹³ï¼šæ¨è¿›å™¨å¯åŠ¨ (æ­£åœ¨è¿œç¦»)";
                    statusEl.style.color = "#ff4444";
                    
                    // é€»è¾‘ï¼šæ¡æ‹³ + æ‹‰è¿œ (æ‰‹å˜å°) -> æ‘„åƒæœºè¿œç¦»
                    // è¿™é‡Œçš„â€œæ‹‰è¿œâ€æ˜¯æŒ‡ç”¨æˆ·ç‰©ç†æ‰‹è¿œç¦»æ‘„åƒå¤´ã€‚
                    // æ˜ å°„ï¼šHandSize è¶Šå° -> TargetRadius è¶Šå¤§
                    // ä¸ºäº†å¹³æ»‘ï¼Œæˆ‘ä»¬è®¾å®šç›®æ ‡ä¸ºæœ€å¤§è·ç¦»
                    STATE.targetCameraRadius = CONFIG.maxDist;

                } else if (isPalmOpen(landmarks)) {
                    STATE.gesture = 'OPEN';
                    statusEl.innerText = "ğŸ– å¼ å¼€ï¼šå¼•åŠ›æ•è· (å¿«é€Ÿé è¿‘)";
                    statusEl.style.color = "#44ff44";

                    // é€»è¾‘ï¼šå¼ å¼€ + é è¿‘ (æ‰‹å˜å¤§) -> æ‘„åƒæœºé è¿‘
                    // æ˜ å°„ï¼šHandSize è¶Šå¤§ -> TargetRadius è¶Šå°
                    // è®¾å®šç›®æ ‡ä¸ºæœ€å°è·ç¦»
                    STATE.targetCameraRadius = CONFIG.minDist;

                } else {
                    STATE.gesture = 'NONE';
                    statusEl.innerText = "ğŸ‘‹ è‡ªç”±æ—‹è½¬æ¨¡å¼";
                    statusEl.style.color = "#ff8c00";
                    // è·ç¦»ä¿æŒå½“å‰ä½ç½®ï¼Œæˆ–è€…ç¨å¾®å½’ä½åˆ°é»˜è®¤ï¼Ÿä¿æŒå½“å‰æ¯”è¾ƒå¥½ã€‚
                    STATE.targetCameraRadius = STATE.currentCameraRadius; 
                }

                STATE.lastHandSize = handSize;

            } else {
                STATE.isHandDetected = false;
                statusEl.innerText = "æœªæ£€æµ‹åˆ°æ‰‹åŠ¿";
                statusEl.style.color = "#aaa";
                STATE.gesture = 'NONE';
            }
        }

        // åˆå§‹åŒ– MediaPipe Hands
        const hands = new window.Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // åˆå§‹åŒ–æ‘„åƒå¤´
        const videoElement = document.querySelector('.input_video');
        const cameraUtils = new window.Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });
        cameraUtils.start();

    </script>
</body>
</html>